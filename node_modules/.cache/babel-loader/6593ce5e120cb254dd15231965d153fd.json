{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar MiddlewareStack =\n/** @class */\nfunction () {\n  function MiddlewareStack() {\n    this.absoluteEntries = [];\n    this.relativeEntries = [];\n    this.entriesNameMap = {};\n  }\n\n  MiddlewareStack.prototype.add = function (middleware, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var name = options.name,\n        _a = options.step,\n        step = _a === void 0 ? \"initialize\" : _a,\n        tags = options.tags,\n        _b = options.priority,\n        priority = _b === void 0 ? \"normal\" : _b;\n    var entry = {\n      name: name,\n      step: step,\n      tags: tags,\n      priority: priority,\n      middleware: middleware\n    };\n\n    if (name) {\n      if (Object.prototype.hasOwnProperty.call(this.entriesNameMap, name)) {\n        throw new Error(\"Duplicated middleware name '\" + name + \"'\");\n      }\n\n      this.entriesNameMap[name] = entry;\n    }\n\n    this.absoluteEntries.push(entry);\n  };\n\n  MiddlewareStack.prototype.addRelativeTo = function (middleware, options) {\n    var _a = options.step,\n        step = _a === void 0 ? \"initialize\" : _a,\n        name = options.name,\n        tags = options.tags,\n        relation = options.relation,\n        toMiddleware = options.toMiddleware;\n    var entry = {\n      middleware: middleware,\n      step: step,\n      name: name,\n      tags: tags,\n      next: relation === \"before\" ? toMiddleware : undefined,\n      prev: relation === \"after\" ? toMiddleware : undefined\n    };\n\n    if (name) {\n      if (Object.prototype.hasOwnProperty.call(this.entriesNameMap, name)) {\n        throw new Error(\"Duplicated middleware name '\" + name + \"'\");\n      }\n\n      this.entriesNameMap[name] = entry;\n    }\n\n    this.relativeEntries.push(entry);\n  };\n\n  MiddlewareStack.prototype.sort = function (entries) {\n    //reverse before sorting so that middleware of same step will execute in\n    //the order of being added\n    return entries.sort(function (a, b) {\n      return stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || \"normal\"] - priorityWeights[a.priority || \"normal\"];\n    });\n  };\n\n  MiddlewareStack.prototype.clone = function () {\n    var _a, _b;\n\n    var clone = new MiddlewareStack();\n\n    (_a = clone.absoluteEntries).push.apply(_a, this.absoluteEntries);\n\n    (_b = clone.relativeEntries).push.apply(_b, this.relativeEntries);\n\n    clone.entriesNameMap = tslib_1.__assign({}, this.entriesNameMap);\n    return clone;\n  };\n\n  MiddlewareStack.prototype.concat = function (from) {\n    var _a, _b;\n\n    var clone = new MiddlewareStack();\n    clone.entriesNameMap = tslib_1.__assign({}, this.entriesNameMap); // IMiddlewareStack interface doesn't contain private members variables\n    // like `entriesNameMap`, but in fact the function expects `MiddlewareStack`\n    // class instance. So here we cast it.\n\n    var _from = from;\n\n    for (var name in _from.entriesNameMap) {\n      if (clone.entriesNameMap[name]) {\n        throw new Error(\"Duplicated middleware name '\" + name + \"'\");\n      }\n\n      clone.entriesNameMap[name] = _from.entriesNameMap[name];\n    }\n\n    (_a = clone.absoluteEntries).push.apply(_a, tslib_1.__spreadArrays(this.absoluteEntries, _from.absoluteEntries));\n\n    (_b = clone.relativeEntries).push.apply(_b, tslib_1.__spreadArrays(this.relativeEntries, _from.relativeEntries));\n\n    return clone;\n  };\n\n  MiddlewareStack.prototype.remove = function (toRemove) {\n    if (typeof toRemove === \"string\") return this.removeByName(toRemove);else return this.removeByReference(toRemove);\n  };\n\n  MiddlewareStack.prototype.removeByName = function (toRemove) {\n    for (var i = this.absoluteEntries.length - 1; i >= 0; i--) {\n      if (this.absoluteEntries[i].name && this.absoluteEntries[i].name === toRemove) {\n        this.absoluteEntries.splice(i, 1);\n        delete this.entriesNameMap[toRemove];\n        return true;\n      }\n    }\n\n    for (var i = this.relativeEntries.length - 1; i >= 0; i--) {\n      if (this.relativeEntries[i].name && this.relativeEntries[i].name === toRemove) {\n        this.relativeEntries.splice(i, 1);\n        delete this.entriesNameMap[toRemove];\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  MiddlewareStack.prototype.removeByReference = function (toRemove) {\n    for (var i = this.absoluteEntries.length - 1; i >= 0; i--) {\n      if (this.absoluteEntries[i].middleware === toRemove) {\n        var name = this.absoluteEntries[i].name;\n        if (name) delete this.entriesNameMap[name];\n        this.absoluteEntries.splice(i, 1);\n        return true;\n      }\n    }\n\n    for (var i = this.relativeEntries.length - 1; i >= 0; i--) {\n      if (this.relativeEntries[i].middleware === toRemove) {\n        var name = this.relativeEntries[i].name;\n        if (name) delete this.entriesNameMap[name];\n        this.relativeEntries.splice(i, 1);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  MiddlewareStack.prototype.removeByTag = function (toRemove) {\n    var removed = false;\n\n    for (var i = this.absoluteEntries.length - 1; i >= 0; i--) {\n      var _a = this.absoluteEntries[i],\n          tags = _a.tags,\n          name = _a.name;\n\n      if (tags && tags.indexOf(toRemove) > -1) {\n        this.absoluteEntries.splice(i, 1);\n        if (name) delete this.entriesNameMap[name];\n        removed = true;\n      }\n    }\n\n    for (var i = this.relativeEntries.length - 1; i >= 0; i--) {\n      var _b = this.relativeEntries[i],\n          tags = _b.tags,\n          name = _b.name;\n\n      if (tags && tags.indexOf(toRemove) > -1) {\n        this.relativeEntries.splice(i, 1);\n        if (name) delete this.entriesNameMap[name];\n        removed = true;\n      }\n    }\n\n    return removed;\n  };\n\n  MiddlewareStack.prototype.use = function (plugin) {\n    plugin.applyToStack(this);\n  };\n  /**\n   * Resolve relative middleware entries to multiple double linked lists\n   * depicting the relative location of middleware. Only middleware that have\n   * direct or transitive relation will form a linked list.\n   *\n   * This function normalizes relative middleware into 2 categories of linked\n   * lists. (1) linked list that have absolute-located middleware on one end.\n   * These middleware will be resolved accordingly before or after the absolute-\n   * located middleware. (2) Linked list that have no absolute-located middleware\n   * on any end. They will be resolved to corresponding step with normal priority\n   *\n   * The 2 types of linked list will return as a tuple\n   */\n\n\n  MiddlewareStack.prototype.normalizeRelativeEntries = function () {\n    var absoluteMiddlewareNamesMap = this.absoluteEntries.filter(function (entry) {\n      return entry.name;\n    }).reduce(function (accumulator, entry) {\n      accumulator[entry.name] = entry;\n      return accumulator;\n    }, {});\n    var normalized = this.relativeEntries.map(function (entry) {\n      return tslib_1.__assign(tslib_1.__assign({}, entry), {\n        priority: null,\n        next: undefined,\n        prev: undefined\n      });\n    });\n    var relativeMiddlewareNamesMap = normalized.filter(function (entry) {\n      return entry.name;\n    }).reduce(function (accumulator, entry) {\n      accumulator[entry.name] = entry;\n      return accumulator;\n    }, {});\n    var anchors = {};\n\n    for (var i = 0; i < this.relativeEntries.length; i++) {\n      var _a = this.relativeEntries[i],\n          prev = _a.prev,\n          next = _a.next;\n      var resolvedCurr = normalized[i]; //either prev or next is set\n\n      if (prev) {\n        if (absoluteMiddlewareNamesMap[prev] && absoluteMiddlewareNamesMap[prev].step === resolvedCurr.step) {\n          if (!anchors[prev]) anchors[prev] = {};\n          resolvedCurr.next = anchors[prev].next;\n          if (anchors[prev].next) anchors[prev].next.prev = resolvedCurr;\n          anchors[prev].next = resolvedCurr;\n        } else if (relativeMiddlewareNamesMap[prev] && relativeMiddlewareNamesMap[prev].step === resolvedCurr.step) {\n          var resolvedPrev = relativeMiddlewareNamesMap[prev];\n          if (resolvedPrev.next === resolvedCurr) continue;\n          resolvedCurr.next = resolvedPrev.next;\n          resolvedPrev.next = resolvedCurr;\n          if (resolvedCurr.next) resolvedCurr.next.prev = resolvedCurr;\n          resolvedCurr.prev = resolvedPrev;\n        }\n      } else if (next) {\n        if (absoluteMiddlewareNamesMap[next] && absoluteMiddlewareNamesMap[next].step === resolvedCurr.step) {\n          if (!anchors[next]) anchors[next] = {};\n          resolvedCurr.prev = anchors[next].prev;\n          if (anchors[next].prev) anchors[next].prev.next = resolvedCurr;\n          anchors[next].prev = resolvedCurr;\n        } else if (relativeMiddlewareNamesMap[next] && relativeMiddlewareNamesMap[next].step === resolvedCurr.step) {\n          var resolvedNext = relativeMiddlewareNamesMap[next];\n          if (resolvedNext.prev === resolvedCurr) continue;\n          resolvedCurr.prev = resolvedNext.prev;\n          resolvedNext.prev = resolvedCurr;\n          if (resolvedCurr.prev) resolvedCurr.prev.next = resolvedCurr;\n          resolvedCurr.next = resolvedNext;\n        }\n      }\n    } // get the head of the relative middleware linked list that have\n    // no transitive relation to absolute middleware.\n\n\n    var orphanedRelativeEntries = [];\n    var visited = new WeakSet();\n\n    for (var _i = 0, _b = Object.keys(anchors); _i < _b.length; _i++) {\n      var anchorName = _b[_i];\n      var _c = anchors[anchorName],\n          prev = _c.prev,\n          next = _c.next;\n\n      while (prev) {\n        visited.add(prev);\n        prev = prev.prev;\n      }\n\n      while (next) {\n        visited.add(next);\n        next = next.next;\n      }\n    }\n\n    for (var i = 0; i < normalized.length; i++) {\n      var entry = normalized[i];\n      if (visited.has(entry)) continue;\n      if (!entry.prev) orphanedRelativeEntries.push(entry);\n\n      while (entry && !visited.has(entry)) {\n        visited.add(entry);\n        entry = entry.next;\n      }\n    }\n\n    return [orphanedRelativeEntries, anchors];\n  };\n  /**\n   * Get a final list of middleware in the order of being executed in the resolved handler.\n   * If relative entries list is not empty, those entries will be added to final middleware\n   * list with rules below:\n   * 1. if `toMiddleware` exists in the specific `step`, the middleware will be inserted before\n   *     or after the specified `toMiddleware`\n   * 2. if `toMiddleware` doesn't exist in the specific `step`, the middleware will be appended\n   *     to specific `step` with priority of `normal`\n   */\n\n\n  MiddlewareStack.prototype.getMiddlewareList = function () {\n    var middlewareList = [];\n\n    var _a = this.normalizeRelativeEntries(),\n        orphanedRelativeEntries = _a[0],\n        anchors = _a[1];\n\n    var entryList = tslib_1.__spreadArrays(this.absoluteEntries, orphanedRelativeEntries);\n\n    entryList = this.sort(entryList);\n\n    for (var _i = 0, entryList_1 = entryList; _i < entryList_1.length; _i++) {\n      var entry = entryList_1[_i];\n      var defaultAnchorValue = {\n        prev: undefined,\n        next: undefined\n      };\n\n      var _b = entry.name ? anchors[entry.name] || defaultAnchorValue : defaultAnchorValue,\n          prev = _b.prev,\n          next = _b.next;\n\n      var relativeEntry = prev; //reverse relative entry linked list and add to ordered handler list\n\n      while (relativeEntry === null || relativeEntry === void 0 ? void 0 : relativeEntry.prev) {\n        relativeEntry = relativeEntry.prev;\n      }\n\n      while (relativeEntry) {\n        middlewareList.push(relativeEntry.middleware);\n        relativeEntry = relativeEntry.next;\n      }\n\n      middlewareList.push(entry.middleware);\n      var orphanedEntry = entry;\n\n      while (orphanedEntry.next) {\n        middlewareList.push(orphanedEntry.next.middleware);\n        orphanedEntry = orphanedEntry.next;\n      }\n\n      relativeEntry = next;\n\n      while (relativeEntry) {\n        middlewareList.push(relativeEntry.middleware);\n        relativeEntry = relativeEntry.next;\n      }\n    }\n\n    return middlewareList.reverse();\n  };\n\n  MiddlewareStack.prototype.resolve = function (handler, context) {\n    for (var _i = 0, _a = this.getMiddlewareList(); _i < _a.length; _i++) {\n      var middleware = _a[_i];\n      handler = middleware(handler, context);\n    }\n\n    return handler;\n  };\n\n  return MiddlewareStack;\n}();\n\nexports.MiddlewareStack = MiddlewareStack;\nvar stepWeights = {\n  initialize: 5,\n  serialize: 4,\n  build: 3,\n  finalizeRequest: 2,\n  deserialize: 1\n};\nvar priorityWeights = {\n  high: 3,\n  normal: 2,\n  low: 1\n};","map":null,"metadata":{},"sourceType":"script"}