{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { Buffer } from 'buffer';\nimport CryptoJS from 'crypto-js/core';\nimport { monotonicFactory } from 'ulid';\nimport { v4 as uuid } from 'uuid';\nimport { isPredicateGroup, isPredicateObj } from './types';\nexport var exhaustiveCheck = function exhaustiveCheck(obj, throwOnError) {\n  if (throwOnError === void 0) {\n    throwOnError = true;\n  }\n\n  if (throwOnError) {\n    throw new Error(\"Invalid \" + obj);\n  }\n};\nexport var validatePredicate = function validatePredicate(model, groupType, predicatesOrGroups) {\n  var filterType;\n  var isNegation = false;\n\n  if (predicatesOrGroups.length === 0) {\n    return true;\n  }\n\n  switch (groupType) {\n    case 'not':\n      filterType = 'every';\n      isNegation = true;\n      break;\n\n    case 'and':\n      filterType = 'every';\n      break;\n\n    case 'or':\n      filterType = 'some';\n      break;\n\n    default:\n      exhaustiveCheck(groupType);\n  }\n\n  var result = predicatesOrGroups[filterType](function (predicateOrGroup) {\n    if (isPredicateObj(predicateOrGroup)) {\n      var field = predicateOrGroup.field,\n          operator = predicateOrGroup.operator,\n          operand = predicateOrGroup.operand;\n      var value = model[field];\n      return validatePredicateField(value, operator, operand);\n    }\n\n    if (isPredicateGroup(predicateOrGroup)) {\n      var type = predicateOrGroup.type,\n          predicates = predicateOrGroup.predicates;\n      return validatePredicate(model, type, predicates);\n    }\n\n    throw new Error('Not a predicate or group');\n  });\n  return isNegation ? !result : result;\n};\n\nvar validatePredicateField = function validatePredicateField(value, operator, operand) {\n  switch (operator) {\n    case 'ne':\n      return value !== operand;\n\n    case 'eq':\n      return value === operand;\n\n    case 'le':\n      return value <= operand;\n\n    case 'lt':\n      return value < operand;\n\n    case 'ge':\n      return value >= operand;\n\n    case 'gt':\n      return value > operand;\n\n    case 'between':\n      var _a = __read(operand, 2),\n          min = _a[0],\n          max = _a[1];\n\n      return value >= min && value <= max;\n\n    case 'beginsWith':\n      return value.startsWith(operand);\n\n    case 'contains':\n      return value.indexOf(operand) > -1;\n\n    case 'notContains':\n      return value.indexOf(operand) === -1;\n\n    default:\n      exhaustiveCheck(operator, false);\n      return false;\n  }\n};\n\nexport var isModelConstructor = function isModelConstructor(obj) {\n  return obj && typeof obj.copyOf === 'function';\n};\nexport var establishRelation = function establishRelation(namespace) {\n  var relationship = {};\n  Object.keys(namespace.models).forEach(function (mKey) {\n    relationship[mKey] = {\n      indexes: [],\n      relationTypes: []\n    };\n    var model = namespace.models[mKey];\n    Object.keys(model.fields).forEach(function (attr) {\n      var fieldAttribute = model.fields[attr];\n\n      if (typeof fieldAttribute.type === 'object' && 'model' in fieldAttribute.type) {\n        var connectionType = fieldAttribute.association.connectionType;\n        relationship[mKey].relationTypes.push({\n          fieldName: fieldAttribute.name,\n          modelName: fieldAttribute.type.model,\n          relationType: connectionType,\n          targetName: fieldAttribute.association['targetName'],\n          associatedWith: fieldAttribute.association['associatedWith']\n        });\n\n        if (connectionType === 'BELONGS_TO') {\n          relationship[mKey].indexes.push(fieldAttribute.association['targetName']);\n        }\n      }\n    }); // create indexes from key fields\n\n    if (model.attributes) {\n      model.attributes.forEach(function (attribute) {\n        if (attribute.type === 'key') {\n          var fields = attribute.properties.fields;\n\n          if (fields) {\n            fields.forEach(function (field) {\n              // only add index if it hasn't already been added\n              var exists = relationship[mKey].indexes.includes(field);\n\n              if (!exists) {\n                relationship[mKey].indexes.push(field);\n              }\n            });\n          }\n        }\n      });\n    }\n  });\n  return relationship;\n};\nvar topologicallySortedModels = new WeakMap();\nexport var traverseModel = function traverseModel(srcModelName, instance, namespace, modelInstanceCreator, getModelConstructorByModelName) {\n  var relationships = namespace.relationships;\n  var modelConstructor = getModelConstructorByModelName(namespace.name, srcModelName);\n  var relation = relationships[srcModelName];\n  var result = [];\n  var newInstance = modelConstructor.copyOf(instance, function (draftInstance) {\n    relation.relationTypes.forEach(function (rItem) {\n      var modelConstructor = getModelConstructorByModelName(namespace.name, rItem.modelName);\n\n      switch (rItem.relationType) {\n        case 'HAS_ONE':\n          if (instance[rItem.fieldName]) {\n            var modelInstance = void 0;\n\n            try {\n              modelInstance = modelInstanceCreator(modelConstructor, instance[rItem.fieldName]);\n            } catch (error) {// Do nothing\n            }\n\n            result.push({\n              modelName: rItem.modelName,\n              item: instance[rItem.fieldName],\n              instance: modelInstance\n            });\n            draftInstance[rItem.fieldName] = draftInstance[rItem.fieldName].id;\n          }\n\n          break;\n\n        case 'BELONGS_TO':\n          if (instance[rItem.fieldName]) {\n            var modelInstance = void 0;\n\n            try {\n              modelInstance = modelInstanceCreator(modelConstructor, instance[rItem.fieldName]);\n            } catch (error) {// Do nothing\n            }\n\n            var isDeleted = draftInstance[rItem.fieldName]._deleted;\n\n            if (!isDeleted) {\n              result.push({\n                modelName: rItem.modelName,\n                item: instance[rItem.fieldName],\n                instance: modelInstance\n              });\n            }\n          }\n\n          draftInstance[rItem.targetName] = draftInstance[rItem.fieldName] ? draftInstance[rItem.fieldName].id : null;\n          delete draftInstance[rItem.fieldName];\n          break;\n\n        case 'HAS_MANY':\n          // Intentionally blank\n          break;\n\n        default:\n          exhaustiveCheck(rItem.relationType);\n          break;\n      }\n    });\n  });\n  result.unshift({\n    modelName: srcModelName,\n    item: newInstance,\n    instance: newInstance\n  });\n\n  if (!topologicallySortedModels.has(namespace)) {\n    topologicallySortedModels.set(namespace, Array.from(namespace.modelTopologicalOrdering.keys()));\n  }\n\n  var sortedModels = topologicallySortedModels.get(namespace);\n  result.sort(function (a, b) {\n    return sortedModels.indexOf(a.modelName) - sortedModels.indexOf(b.modelName);\n  });\n  return result;\n};\nexport var getIndex = function getIndex(rel, src) {\n  var index = '';\n  rel.some(function (relItem) {\n    if (relItem.modelName === src) {\n      index = relItem.targetName;\n    }\n  });\n  return index;\n};\nexport var getIndexFromAssociation = function getIndexFromAssociation(indexes, src) {\n  var index = indexes.find(function (idx) {\n    return idx === src;\n  });\n  return index;\n};\nexport var NAMESPACES;\n\n(function (NAMESPACES) {\n  NAMESPACES[\"DATASTORE\"] = \"datastore\";\n  NAMESPACES[\"USER\"] = \"user\";\n  NAMESPACES[\"SYNC\"] = \"sync\";\n  NAMESPACES[\"STORAGE\"] = \"storage\";\n})(NAMESPACES || (NAMESPACES = {}));\n\nvar DATASTORE = NAMESPACES.DATASTORE;\nvar USER = NAMESPACES.USER;\nvar SYNC = NAMESPACES.SYNC;\nvar STORAGE = NAMESPACES.STORAGE;\nexport { USER, SYNC, STORAGE, DATASTORE };\nvar privateModeCheckResult;\nexport var isPrivateMode = function isPrivateMode() {\n  return new Promise(function (resolve) {\n    var dbname = uuid();\n    var db;\n\n    var isPrivate = function isPrivate() {\n      privateModeCheckResult = false;\n      resolve(true);\n    };\n\n    var isNotPrivate = function isNotPrivate() {\n      return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(db && db.result && typeof db.result.close === 'function')) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , db.result.close()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              return [4\n              /*yield*/\n              , indexedDB.deleteDatabase(dbname)];\n\n            case 3:\n              _a.sent();\n\n              privateModeCheckResult = true;\n              return [2\n              /*return*/\n              , resolve(false)];\n          }\n        });\n      });\n    };\n\n    if (privateModeCheckResult === true) {\n      return isNotPrivate();\n    }\n\n    if (privateModeCheckResult === false) {\n      return isPrivate();\n    }\n\n    if (indexedDB === null) return isPrivate();\n    db = indexedDB.open(dbname);\n    db.onerror = isPrivate;\n    db.onsuccess = isNotPrivate;\n  });\n};\n\nvar randomBytes = function randomBytes(nBytes) {\n  return Buffer.from(CryptoJS.lib.WordArray.random(nBytes).toString(), 'hex');\n};\n\nvar prng = function prng() {\n  return randomBytes(1).readUInt8(0) / 0xff;\n};\n\nexport function monotonicUlidFactory(seed) {\n  var ulid = monotonicFactory(prng);\n  return function () {\n    return ulid(seed);\n  };\n}\n/**\n * Uses performance.now() if available, otherwise, uses Date.now() (e.g. react native without a polyfill)\n *\n * The values returned by performance.now() always increase at a constant rate,\n * independent of the system clock (which might be adjusted manually or skewed\n * by software like NTP).\n *\n * Otherwise, performance.timing.navigationStart + performance.now() will be\n * approximately equal to Date.now()\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Example\n */\n\nexport function getNow() {\n  if (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') {\n    return performance.now() | 0; // convert to integer\n  } else {\n    return Date.now();\n  }\n}","map":null,"metadata":{},"sourceType":"module"}