{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { Amplify, ConsoleLogger as Logger, Hub } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze } from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { isPredicatesAll, ModelPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType } from '../types';\nimport { DATASTORE, establishRelation, exhaustiveCheck, isModelConstructor, monotonicUlidFactory, STORAGE, SYNC, USER } from '../util';\nsetAutoFreeze(true);\nvar logger = new Logger('DataStore');\nvar ulid = monotonicUlidFactory(Date.now());\nvar SETTING_SCHEMA_VERSION = 'schemaVersion';\nvar storage;\nvar schema;\nvar modelNamespaceMap = new WeakMap();\n\nvar getModelDefinition = function getModelDefinition(modelConstructor) {\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  return schema.namespaces[namespace].models[modelConstructor.name];\n};\n\nvar isValidModelConstructor = function isValidModelConstructor(obj) {\n  return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\n\nvar namespaceResolver = function namespaceResolver(modelConstructor) {\n  return modelNamespaceMap.get(modelConstructor);\n};\n\nvar dataStoreClasses;\nvar userClasses;\nvar syncClasses;\nvar storageClasses;\n\nvar initSchema = function initSchema(userSchema) {\n  var _a;\n\n  if (schema !== undefined) {\n    throw new Error('The schema has already been initialized');\n  }\n\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n\n  var internalUserNamespace = __assign({\n    name: USER\n  }, userSchema);\n\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  var dataStoreNamespace = getNamespace();\n  var storageNamespace = Storage.getNamespace();\n  var syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: (_a = {}, _a[dataStoreNamespace.name] = dataStoreNamespace, _a[internalUserNamespace.name] = internalUserNamespace, _a[storageNamespace.name] = storageNamespace, _a[syncNamespace.name] = syncNamespace, _a),\n    version: userSchema.version\n  };\n  Object.keys(schema.namespaces).forEach(function (namespace) {\n    var e_1, _a;\n\n    schema.namespaces[namespace].relationships = establishRelation(schema.namespaces[namespace]);\n    var modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(function (model) {\n      var connectedModels = [];\n      Object.values(model.fields).filter(function (field) {\n        return field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name;\n      }).forEach(function (field) {\n        return connectedModels.push(field.type.model);\n      });\n      modelAssociations.set(model.name, connectedModels);\n    });\n    var result = new Map();\n    var count = 1000;\n\n    while (true && count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n\n      count--;\n\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n\n      try {\n        for (var _b = (e_1 = void 0, __values(Array.from(modelAssociations.keys()))), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var modelName = _c.value;\n          var parents = modelAssociations.get(modelName);\n\n          if (parents.every(function (x) {\n            return result.has(x);\n          })) {\n            result.set(modelName, parents);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      Array.from(result.keys()).forEach(function (x) {\n        return modelAssociations.delete(x);\n      });\n    }\n\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\n\nvar createTypeClasses = function createTypeClasses(namespace) {\n  var classes = {};\n  Object.entries(namespace.models).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        modelName = _b[0],\n        modelDefinition = _b[1];\n\n    var clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        typeName = _b[0],\n        typeDefinition = _b[1];\n\n    var clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\n\nvar instancesMetadata = new WeakSet();\n\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\n\nvar initializeInstance = function initializeInstance(init, modelDefinition, draft) {\n  Object.entries(init).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        k = _b[0],\n        v = _b[1];\n\n    var fieldDefinition = modelDefinition.fields[k];\n\n    if (fieldDefinition !== undefined) {\n      var type = fieldDefinition.type,\n          isRequired = fieldDefinition.isRequired,\n          name_1 = fieldDefinition.name,\n          isArray = fieldDefinition.isArray;\n\n      if (isRequired && (v === null || v === undefined)) {\n        throw new Error(\"Field \" + name_1 + \" is required\");\n      }\n\n      if (isGraphQLScalarType(type)) {\n        var jsType_1 = GraphQLScalarType.getJSType(type);\n\n        if (isArray) {\n          if (!Array.isArray(v)) {\n            throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \"[], \" + typeof v + \" received. \" + v);\n          }\n\n          if (v.some(function (e) {\n            return typeof e !== jsType_1;\n          })) {\n            var elemTypes = v.map(function (e) {\n              return typeof e;\n            }).join(',');\n            throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + jsType_1 + \", [\" + elemTypes + \"] received. \" + v);\n          }\n        } else if (typeof v !== jsType_1 && v !== null) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \", \" + typeof v + \" received. \" + v);\n        }\n      }\n    }\n\n    draft[k] = v;\n  });\n};\n\nvar createModelClass = function createModelClass(modelDefinition) {\n  var clazz =\n  /** @class */\n  function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, modelDefinition, draft);\n        var modelInstanceMetadata = instancesMetadata.has(init) ? init : {};\n        var _id = modelInstanceMetadata.id,\n            _version = modelInstanceMetadata._version,\n            _lastChangedAt = modelInstanceMetadata._lastChangedAt,\n            _deleted = modelInstanceMetadata._deleted;\n        var id = // instancesIds is set by modelInstanceCreator, it is accessible only internally\n        _id !== null && _id !== undefined ? _id : modelDefinition.syncable ? uuid4() : ulid();\n        draft.id = id;\n\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      });\n      return instance;\n    }\n\n    Model.copyOf = function (source, fn) {\n      var modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n\n      if (!isValidModelConstructor(modelConstructor)) {\n        var msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source: source\n        });\n        throw new Error(msg);\n      }\n\n      return produce(source, function (draft) {\n        fn(draft);\n        draft.id = source.id;\n      });\n    };\n\n    return Model;\n  }();\n\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n  return clazz;\n};\n\nvar createNonModelClass = function createNonModelClass(typeDefinition) {\n  var clazz =\n  /** @class */\n  function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n\n    return Model;\n  }();\n\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  return clazz;\n};\n\nvar save = function save(model, condition) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var modelConstructor, msg, modelDefinition, producedCondition, _a, savedModel;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , start()];\n\n        case 1:\n          _b.sent();\n\n          modelConstructor = model ? model.constructor : undefined;\n\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Object is not an instance of a valid model';\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n\n          modelDefinition = getModelDefinition(modelConstructor);\n          producedCondition = ModelPredicateCreator.createFromExisting(modelDefinition, condition);\n          return [4\n          /*yield*/\n          , storage.runExclusive(function (s) {\n            return __awaiter(void 0, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , s.save(model, producedCondition)];\n\n                  case 1:\n                    _a.sent();\n\n                    return [2\n                    /*return*/\n                    , s.query(modelConstructor, ModelPredicateCreator.createForId(modelDefinition, model.id))];\n                }\n              });\n            });\n          })];\n\n        case 2:\n          _a = __read.apply(void 0, [_b.sent(), 1]), savedModel = _a[0];\n          return [2\n          /*return*/\n          , savedModel];\n      }\n    });\n  });\n};\n\nvar remove = function remove(modelOrConstructor, idOrCriteria) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var condition, msg, modelConstructor, msg, msg, _a, deleted, model, modelConstructor, msg, modelDefinition, idPredicate, msg, _b, _c, deleted;\n\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , start()];\n\n        case 1:\n          _d.sent();\n\n          if (!modelOrConstructor) {\n            msg = 'Model or Model Constructor required';\n            logger.error(msg, {\n              modelOrConstructor: modelOrConstructor\n            });\n            throw new Error(msg);\n          }\n\n          if (!isValidModelConstructor(modelOrConstructor)) return [3\n          /*break*/\n          , 3];\n          modelConstructor = modelOrConstructor;\n\n          if (!idOrCriteria) {\n            msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n            logger.error(msg, {\n              idOrCriteria: idOrCriteria\n            });\n            throw new Error(msg);\n          }\n\n          if (typeof idOrCriteria === 'string') {\n            condition = ModelPredicateCreator.createForId(getModelDefinition(modelConstructor), idOrCriteria);\n          } else {\n            condition = ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor),\n            /**\n             * idOrCriteria is always a ProducerModelPredicate<T>, never a symbol.\n             * The symbol is used only for typing purposes. e.g. see Predicates.ALL\n             */\n            idOrCriteria);\n\n            if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n              msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n              logger.error(msg, {\n                condition: condition\n              });\n              throw new Error(msg);\n            }\n          }\n\n          return [4\n          /*yield*/\n          , storage.delete(modelConstructor, condition)];\n\n        case 2:\n          _a = __read.apply(void 0, [_d.sent(), 1]), deleted = _a[0];\n          return [2\n          /*return*/\n          , deleted];\n\n        case 3:\n          model = modelOrConstructor;\n          modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Object is not an instance of a valid model';\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n\n          modelDefinition = getModelDefinition(modelConstructor);\n          idPredicate = ModelPredicateCreator.createForId(modelDefinition, model.id);\n\n          if (idOrCriteria) {\n            if (typeof idOrCriteria !== 'function') {\n              msg = 'Invalid criteria';\n              logger.error(msg, {\n                idOrCriteria: idOrCriteria\n              });\n              throw new Error(msg);\n            }\n\n            condition = idOrCriteria(idPredicate);\n          } else {\n            condition = idPredicate;\n          }\n\n          return [4\n          /*yield*/\n          , storage.delete(model, condition)];\n\n        case 4:\n          _b = __read.apply(void 0, [_d.sent(), 1]), _c = __read(_b[0], 1), deleted = _c[0];\n          return [2\n          /*return*/\n          , deleted];\n      }\n    });\n  });\n};\n\nvar observe = function observe(modelOrConstructor, idOrCriteria) {\n  var predicate;\n  var modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor) ? modelOrConstructor : undefined;\n\n  if (modelOrConstructor && modelConstructor === undefined) {\n    var model = modelOrConstructor;\n    var modelConstructor_1 = model && Object.getPrototypeOf(model).constructor;\n\n    if (isValidModelConstructor(modelConstructor_1)) {\n      if (idOrCriteria) {\n        logger.warn('idOrCriteria is ignored when using a model instance', {\n          model: model,\n          idOrCriteria: idOrCriteria\n        });\n      }\n\n      return observe(modelConstructor_1, model.id);\n    } else {\n      var msg = 'The model is not an instance of a PersistentModelConstructor';\n      logger.error(msg, {\n        model: model\n      });\n      throw new Error(msg);\n    }\n  }\n\n  if (idOrCriteria !== undefined && modelConstructor === undefined) {\n    var msg = 'Cannot provide criteria without a modelConstructor';\n    logger.error(msg, idOrCriteria);\n    throw new Error(msg);\n  }\n\n  if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n    var msg = 'Constructor is not for a valid model';\n    logger.error(msg, {\n      modelConstructor: modelConstructor\n    });\n    throw new Error(msg);\n  }\n\n  if (typeof idOrCriteria === 'string') {\n    predicate = ModelPredicateCreator.createForId(getModelDefinition(modelConstructor), idOrCriteria);\n  } else {\n    predicate = modelConstructor && ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor), idOrCriteria);\n  }\n\n  return new Observable(function (observer) {\n    var handle;\n\n    (function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , start()];\n\n            case 1:\n              _a.sent();\n\n              handle = storage.observe(modelConstructor, predicate).filter(function (_a) {\n                var model = _a.model;\n                return namespaceResolver(model) === USER;\n              }).subscribe(observer);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    })();\n\n    return function () {\n      if (handle) {\n        handle.unsubscribe();\n      }\n    };\n  });\n};\n\nfunction isQueryOne(obj) {\n  return typeof obj === 'string';\n}\n\nvar query = function query(modelConstructor, idOrCriteria, pagination) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var msg, modelDefinition, predicate, _a, limit, page, result;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , start()];\n\n        case 1:\n          _b.sent(); //#region Input validation\n\n\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Constructor is not for a valid model';\n            logger.error(msg, {\n              modelConstructor: modelConstructor\n            });\n            throw new Error(msg);\n          }\n\n          if (typeof idOrCriteria === 'string') {\n            if (pagination !== undefined) {\n              logger.warn('Pagination is ignored when querying by id');\n            }\n          }\n\n          modelDefinition = getModelDefinition(modelConstructor);\n\n          if (isQueryOne(idOrCriteria)) {\n            predicate = ModelPredicateCreator.createForId(modelDefinition, idOrCriteria);\n          } else {\n            if (isPredicatesAll(idOrCriteria)) {\n              // Predicates.ALL means \"all records\", so no predicate (undefined)\n              predicate = undefined;\n            } else {\n              predicate = ModelPredicateCreator.createFromExisting(modelDefinition, idOrCriteria);\n            }\n          }\n\n          _a = pagination || {}, limit = _a.limit, page = _a.page;\n\n          if (page !== undefined && limit === undefined) {\n            throw new Error('Limit is required when requesting a page');\n          }\n\n          if (page !== undefined) {\n            if (typeof page !== 'number') {\n              throw new Error('Page should be a number');\n            }\n\n            if (page < 0) {\n              throw new Error(\"Page can't be negative\");\n            }\n          }\n\n          if (limit !== undefined) {\n            if (typeof limit !== 'number') {\n              throw new Error('Limit should be a number');\n            }\n\n            if (limit < 0) {\n              throw new Error(\"Limit can't be negative\");\n            }\n          } //#endregion\n\n\n          logger.debug('params ready', {\n            modelConstructor: modelConstructor,\n            predicate: ModelPredicateCreator.getPredicates(predicate, false),\n            pagination: pagination\n          });\n          return [4\n          /*yield*/\n          , storage.query(modelConstructor, predicate, pagination)];\n\n        case 2:\n          result = _b.sent();\n          return [2\n          /*return*/\n          , isQueryOne(idOrCriteria) ? result[0] : result];\n      }\n    });\n  });\n};\n\nvar sync;\nvar amplifyConfig = {};\nvar conflictHandler;\nvar errorHandler;\nvar maxRecordsToSync;\nvar syncPageSize;\nvar fullSyncInterval;\n\nfunction configure(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var configDataStore = config.DataStore,\n      configConflictHandler = config.conflictHandler,\n      configErrorHandler = config.errorHandler,\n      configMaxRecordsToSync = config.maxRecordsToSync,\n      configSyncPageSize = config.syncPageSize,\n      configFullSyncInterval = config.fullSyncInterval,\n      configFromAmplify = __rest(config, [\"DataStore\", \"conflictHandler\", \"errorHandler\", \"maxRecordsToSync\", \"syncPageSize\", \"fullSyncInterval\"]);\n\n  amplifyConfig = __assign(__assign({}, configFromAmplify), amplifyConfig);\n  conflictHandler = configDataStore && configDataStore.conflictHandler || conflictHandler || config.conflictHandler || defaultConflictHandler;\n  errorHandler = configDataStore && configDataStore.errorHandler || errorHandler || config.errorHandler || defaultErrorHandler;\n  maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || maxRecordsToSync || config.maxRecordsToSync;\n  syncPageSize = configDataStore && configDataStore.syncPageSize || syncPageSize || config.syncPageSize;\n  fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || config.fullSyncInterval || 24 * 60; // 1 day\n}\n\nfunction defaultConflictHandler(conflictData) {\n  var localModel = conflictData.localModel,\n      modelConstructor = conflictData.modelConstructor,\n      remoteModel = conflictData.remoteModel;\n  var _version = remoteModel._version;\n  return modelInstanceCreator(modelConstructor, __assign(__assign({}, localModel), {\n    _version: _version\n  }));\n}\n\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\n\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  var result;\n\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n\n    case USER:\n      result = userClasses[modelName];\n      break;\n\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n\n    default:\n      exhaustiveCheck(namespaceName);\n      break;\n  }\n\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    var msg = \"Model name is not valid for namespace. modelName: \" + modelName + \", namespace: \" + namespaceName;\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\n\nfunction checkSchemaVersion(storage, version) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Setting, modelDefinition;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          Setting = dataStoreClasses.Setting;\n          modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n          return [4\n          /*yield*/\n          , storage.runExclusive(function (s) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a, schemaVersionSetting, storedValue;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , s.query(Setting, ModelPredicateCreator.createFromExisting(modelDefinition, function (c) {\n                      return c.key('eq', SETTING_SCHEMA_VERSION);\n                    }), {\n                      page: 0,\n                      limit: 1\n                    })];\n\n                  case 1:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), schemaVersionSetting = _a[0];\n                    if (!(schemaVersionSetting !== undefined)) return [3\n                    /*break*/\n                    , 4];\n                    storedValue = JSON.parse(schemaVersionSetting.value);\n                    if (!(storedValue !== version)) return [3\n                    /*break*/\n                    , 3];\n                    return [4\n                    /*yield*/\n                    , s.clear(false)];\n\n                  case 2:\n                    _b.sent();\n\n                    _b.label = 3;\n\n                  case 3:\n                    return [3\n                    /*break*/\n                    , 6];\n\n                  case 4:\n                    return [4\n                    /*yield*/\n                    , s.save(modelInstanceCreator(Setting, {\n                      key: SETTING_SCHEMA_VERSION,\n                      value: JSON.stringify(version)\n                    }))];\n\n                  case 5:\n                    _b.sent();\n\n                    _b.label = 6;\n\n                  case 6:\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          })];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nvar syncSubscription;\nvar initResolve;\nvar initReject;\nvar initialized;\n\nfunction start() {\n  return __awaiter(this, void 0, void 0, function () {\n    var aws_appsync_graphqlEndpoint, fullSyncIntervalInMilliseconds;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(initialized === undefined)) return [3\n          /*break*/\n          , 1];\n          logger.debug('Starting DataStore');\n          initialized = new Promise(function (res, rej) {\n            initResolve = res;\n            initReject = rej;\n          });\n          return [3\n          /*break*/\n          , 3];\n\n        case 1:\n          return [4\n          /*yield*/\n          , initialized];\n\n        case 2:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n\n        case 3:\n          storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator);\n          return [4\n          /*yield*/\n          , storage.init()];\n\n        case 4:\n          _a.sent();\n\n          return [4\n          /*yield*/\n          , checkSchemaVersion(storage, schema.version)];\n\n        case 5:\n          _a.sent();\n\n          aws_appsync_graphqlEndpoint = amplifyConfig.aws_appsync_graphqlEndpoint;\n\n          if (aws_appsync_graphqlEndpoint) {\n            logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n            sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, storage, modelInstanceCreator, maxRecordsToSync, syncPageSize, conflictHandler, errorHandler);\n            fullSyncIntervalInMilliseconds = fullSyncInterval * 1000 * 60;\n            syncSubscription = sync.start({\n              fullSyncInterval: fullSyncIntervalInMilliseconds\n            }).subscribe({\n              next: function next(_a) {\n                var type = _a.type,\n                    data = _a.data;\n\n                if (type === ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED) {\n                  initResolve();\n                }\n\n                Hub.dispatch('datastore', {\n                  event: type,\n                  data: data\n                });\n              },\n              error: function error(err) {\n                logger.warn('Sync error', err);\n                initReject();\n              }\n            });\n          } else {\n            logger.info(\"Data won't be synchronized. No GraphQL endpoint configured.\", {\n              config: amplifyConfig\n            });\n            initResolve();\n          }\n\n          return [4\n          /*yield*/\n          , initialized];\n\n        case 6:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction clear() {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (storage === undefined) {\n            return [2\n            /*return*/\n            ];\n          }\n\n          if (syncSubscription && !syncSubscription.closed) {\n            syncSubscription.unsubscribe();\n          }\n\n          return [4\n          /*yield*/\n          , storage.clear()];\n\n        case 1:\n          _a.sent();\n\n          initialized = undefined; // Should re-initialize when start() is called.\n\n          storage = undefined;\n          sync = undefined;\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction getNamespace() {\n  var namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    this.start = start;\n    this.query = query;\n    this.save = save;\n    this.delete = remove;\n    this.observe = observe;\n    this.configure = configure;\n    this.clear = clear;\n    Amplify.register(this);\n  }\n\n  DataStore.prototype.getModuleName = function () {\n    return 'DataStore';\n  };\n\n  return DataStore;\n}();\n\nvar instance = new DataStore();\nexport { initSchema, instance as DataStore };","map":null,"metadata":{},"sourceType":"module"}